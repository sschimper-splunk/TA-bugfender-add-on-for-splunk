{"basic_builder": {"appname": "TA-bugfender-add-on-for-splunk", "friendly_name": "Bugfender Add-on for Splunk", "version": "1.0.10", "author": "Sebastian Schimper", "description": "", "theme": "#65A637", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAAx1JREFUWEftmHlPKkEQxBtFxBNB8Ubw9vt/GvDCO16IggqIRvPrvN6MCAu7vvjIi/2Xujsz1VXVNRsj0mcV6TM80t+A8vn8+79gbGdnxyPmE0O/gP7I8X8zFI/Htc9IJCKvr6/SbDYD2zA0QwMDA7KxsSH1el1qtZokk0l5fHyUi4sLBbG4uCjj4+Nyd3cnAB0ZGZH9/X15f/efldCAEomEPDw89MwArAGwWq36rgkNCHYODg68jufn5wWQMMDhb29vcn19LZVKxZNxbW1N1/hVIEDINDExIel0WumnstmsPD09ye3t7ZdzALa6uqrAkJMCVLlclvv7+7byBQK0tbUlu7u7ygBM2O8ctLm5qUYuFoueh/DN4eGhjI2NqVyXl5feWt7f29v70kQgQCsrK3JycqKbIJmxNDQ0pAB5DgBqe3tbCoWCTE5OqmwAohHzUC6Xk6Ojo+8BQqqbmxvtmJF+eXnRDXsBxHvIZwymUimdwNYKxJBJZN2z2dTUlMRiMd0chszE09PTytDS0pI8Pz+rb+x9/OPu4YLqGRBZQlfkjDE1MzMjpVKpa7ZwoMlt3slkMso2ORYaEIvxwfDwsG4EO3TbSxGUNOOaGemZ0FCAmBgSmdHHM41GQ8HxdyTxK/c9dxgwusWBre9ZMkAgFV26KW2d+wFymTTvIBkx0Hrf9QyIA83UhJuNt5tFnUC5I47Jz8/PP2VYKMlYhIlJZJcVkvr4+NhXMgMNU9x/ZBaXsU1eaEDLy8tydnam663r0dFRvbfwVLvCcwAhFtwcckM2NCAmxNKZ7CGFGV38gLHpnuuDikajms68Q7obSwCEofX1dW+v0IDsE2J2dlZvbbJpbm7Okwxgp6enur8ZH2B4jjuQgiWyywK0ldVApnYXcwjXAN0CZHBwULOJyaH4KlhYWJCrqytlDmbwm10dnUwXGlA7U5rpDZD7MQa7gOzETOAcau2IAwg5coRDyCh+tjhAGrILjwEEz5n//EYyNEPtNsVTSAdYpu5HP/J9g+cbD/8qQ9/A4S39BdSNxY4MdVv4E8/7+/9DP8FAtzM+AM+QJUNo5xoEAAAAAElFTkSuQmCC", "visible": true, "tab_version": "4.1.3", "tab_build_no": "0", "build_no": 14}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "bugfender:app:list", "interval": "500", "use_external_validation": true, "streaming_mode_xml": true, "name": "bugfender_app_list", "title": "Bugfender - App List", "description": "", "type": "customized", "parameters": [{"required": true, "name": "global_account", "label": "Global Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "global_account", "title": "Global Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # global_account = definition.parameters.get('global_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    \"\"\"Implement your data collection logic here\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_global_account = helper.get_arg('global_account')\n    # In single instance mode, to get arguments of a particular input, use\n    opt_global_account = helper.get_arg('global_account', stanza_name)\n\n    # get input type\n    helper.get_input_type()\n\n    # The following examples get input stanzas.\n    # get all detailed input stanzas\n    helper.get_input_stanza()\n    # get specific input stanza with stanza name\n    helper.get_input_stanza(stanza_name)\n    # get all stanza names\n    helper.get_input_stanza_names()\n\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    account = helper.get_user_credential_by_username(\"username\")\n    account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    global_userdefined_global_var = helper.get_global_setting(\"userdefined_global_var\")\n\n    # The following examples show usage of logging related helper functions.\n    # write to the log for this modular input using configured global log level or INFO as default\n    helper.log(\"log message\")\n    # write to the log using specified log level\n    helper.log_debug(\"log message\")\n    helper.log_info(\"log message\")\n    helper.log_warning(\"log message\")\n    helper.log_error(\"log message\")\n    helper.log_critical(\"log message\")\n    # set the log level for this modular input\n    # (log_level can be \"debug\", \"info\", \"warning\", \"error\" or \"critical\", case insensitive)\n    helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(url, method, parameters=None, payload=None,\n                                        headers=None, cookies=None, verify=True, cert=None,\n                                        timeout=None, use_proxy=True)\n    # get the response headers\n    r_headers = response.headers\n    # get the response body as text\n    r_text = response.text\n    # get response body as json. If the body text is not a json string, raise a ValueError\n    r_json = response.json()\n    # get response cookies\n    r_cookies = response.cookies\n    # get redirect history\n    historical_responses = response.history\n    # get response status code\n    r_status = response.status_code\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n    # The following examples show usage of check pointing related helper functions.\n    # save checkpoint\n    helper.save_check_point(key, state)\n    # delete checkpoint\n    helper.delete_check_point(key)\n    # get checkpoint\n    state = helper.get_check_point(key)\n\n    # To create a splunk event\n    helper.new_event(data, time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    \"\"\"\n\n    '''\n    # The following example writes a random number as an event. (Multi Instance Mode)\n    # Use this code template by default.\n    import random\n    data = str(random.randint(0,100))\n    event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=data)\n    ew.write_event(event)\n    '''\n\n    '''\n    # The following example writes a random number as an event for each input config. (Single Instance Mode)\n    # For advanced users, if you want to create single instance mod input, please use this code template.\n    # Also, you need to uncomment use_single_instance_mode() above.\n    import random\n    input_type = helper.get_input_type()\n    for stanza_name in helper.get_input_stanza_names():\n        data = str(random.randint(0,100))\n        event = helper.new_event(source=input_type, index=helper.get_output_index(stanza_name), sourcetype=helper.get_sourcetype(stanza_name), data=data)\n        ew.write_event(event)\n    '''\n", "customized_options": [{"name": "global_account", "value": ""}], "uuid": "9809647fdace4571aa36abb51edf4715"}, {"index": "default", "sourcetype": "bugfender:app:devices", "interval": "500", "use_external_validation": true, "streaming_mode_xml": true, "name": "bugfender_app_devices", "title": "Bugfender - App Devices", "description": "", "type": "customized", "parameters": [{"name": "global_account", "label": "Global Account", "help_string": "", "required": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": "", "type": "global_account", "value": ""}, {"name": "app_id", "label": "Bugfender App ID", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}, {"name": "start_date", "label": "Start Date", "help_string": "Please specify a date in RFC3339-format.", "required": false, "format_type": "text", "default_value": "", "placeholder": "2023-04-03T08:45:09Z", "type": "text", "value": ""}, {"name": "end_date", "label": "End Date", "help_string": "Please specify a date in RFC3339-format.", "required": false, "format_type": "text", "default_value": "", "placeholder": "2023-04-03T08:45:09Z", "type": "text", "value": ""}, {"required": false, "name": "order", "label": "Order", "default_value": "seen", "help_string": "", "possible_values": [{"value": "seen", "label": "Seen"}, {"value": "nameaz", "label": "Name [A-Z]"}, {"value": "nameza", "label": "Name [Z-A]"}], "type": "radiogroup", "format_type": "radiogroup", "value": "seen"}, {"name": "page_size", "label": "Page Size", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "global_account", "title": "Global Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "app_id", "title": "Bugfender App ID", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "start_date", "title": "Start Date", "description": "Please specify a date in RFC3339-format.", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": "2023-04-03T08:45:09Z"}, {"type": "customized_var", "name": "end_date", "title": "End Date", "description": "Please specify a date in RFC3339-format.", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": "2023-04-03T08:45:09Z"}, {"type": "customized_var", "name": "order", "title": "Order", "description": "", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "seen", "label": "Seen"}, {"value": "nameaz", "label": "Name [A-Z]"}, {"value": "nameza", "label": "Name [Z-A]"}], "format_type": "radiogroup", "default_value": "seen"}, {"type": "customized_var", "name": "page_size", "title": "Page Size", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # global_account = definition.parameters.get('global_account', None)\n    # app_id = definition.parameters.get('app_id', None)\n    # start_date = definition.parameters.get('start_date', None)\n    # end_date = definition.parameters.get('end_date', None)\n    pass\n\ndef collect_events(helper, ew):\n    import json\n    import bugfender_import_data as bf\n    sys.path.insert(0, os.path.join(os.path.dirname(__file__), \"..\", \"lib\"))\n    \n    # get response from Bugfender API\n    api_endpoint = \"/devices\"\n    devices = bf.get_bugfender_data(helper, api_endpoint, None)\n\n    duplicate_count = 0\n\n    # for each response item ....\n    for device in devices:\n        # ... check if event is already been indexed, use timestamp field as key\n        device_id = device.get(\"id\")\n        checkpoint_key = f\"{helper.get_input_stanza_names()}_{device_id}\"\n        state = helper.get_check_point(checkpoint_key)\n\n        # if not, write to Splunk\n        if state is None:\n            event = helper.new_event(data=json.dumps(device), time=None, source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype())\n            ew.write_event(event)\n            helper.save_check_point(checkpoint_key, \"indexed\")\n        else:\n            duplicate_count = duplicate_count + 1\n\n    helper.log_debug(f\"Response from Bugfender endpoint {api_endpoint} successfully written to Splunk. {duplicate_count} duplicate events were encountered and skipped.\")\n    ", "customized_options": [{"name": "global_account", "value": ""}, {"name": "app_id", "value": ""}, {"name": "start_date", "value": ""}, {"name": "end_date", "value": ""}, {"name": "order", "value": "seen"}, {"name": "page_size", "value": ""}], "uuid": "aab9f762842f46d09b6c71daf44689d0", "sample_count": "3593"}, {"index": "default", "sourcetype": "bugfender:app:logs", "interval": "500", "use_external_validation": true, "streaming_mode_xml": true, "name": "bugfender_app_logs", "title": "Bugfender - App Logs", "description": "", "type": "customized", "parameters": [{"name": "global_account", "label": "Global Account", "help_string": "", "required": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": "", "type": "global_account", "value": ""}, {"name": "app_id", "label": "Bugfender App ID", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}, {"name": "interval_days", "label": "Interval (in days)", "help_string": "If this input runs for the first time, instead of one API Call, several API calls for different time intervals are made. Here you can specify how long the intervals are.", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "global_account", "title": "Global Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "app_id", "title": "Bugfender App ID", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "interval_days", "title": "Interval (in days)", "description": "If this input runs for the first time, instead of one API Call, several API calls for different time intervals are made. Here you can specify how long the intervals are.", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}], "customized_options": [{"name": "global_account", "value": ""}, {"name": "app_id", "value": ""}, {"name": "interval_days", "value": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    interval = helper.get_arg(\"interval_days\")\n    if(interval is None):\n        return\n    try:\n        int(interval)\n    except ValueError:\n        raise ValueError(\"Please enter a number\")\n\ndef collect_events(helper, ew):\n    import json\n    import bugfender_import_data as bf\n    sys.path.insert(0, os.path.join(os.path.dirname(__file__), \"..\", \"lib\"))\n    import ndjson\n    import pytz\n\n    # check the checkpoint\n    # get startdate from checkpoint\n    # last_timestamp_checkpoint_key = f\"{helper.get_input_stanza_names()}_most_recent_timestamp\"\n    # last_timestamp = helper.get_check_point(last_timestamp_checkpoint_key)\n    # helper.log_debug(f\"[-] last timestamp: {last_timestamp}\")\n\n    last_timestamp = bf.get_latest_timestamp(helper)\n\n    # convert timestamp to rfc3339-compliant string to use in API call\n    # start_date = None\n    # if last_timestamp is not None:\n    #    start_date = bf.convert_datetime_to_rfc3339_and_add_second(last_timestamp, helper)\n\n    # get response from Bugfender API\n    api_endpoint = \"/logs/download\"\n    helper.log_debug(f\"Starting to query data from enpoint {api_endpoint} to Splunk.\")\n    response = bf.get_bugfender_data(helper, api_endpoint)\n\n    # convert response from ndsjon string to Python list of Python doctionaries\n    if(type(response) == list):\n        formatted_data = response\n    else:\n        formatted_data = response.json(cls=ndjson.Decoder)\n    \n    helper.log_debug(f\"Data received. Starting to write data queried from enpoint {api_endpoint} to Splunk.\")\n\n    # initialize counters\n    event_count = 0\n\n    # Retrieve latest saved timestamp, if it is None, use date far in the past\n    if last_timestamp is not None:\n        most_recent_event_timestamp = datetime.datetime.strptime(last_timestamp, \"%Y-%m-%dT%H:%M:%SZ\").replace(tzinfo=pytz.utc)\n    else:\n        most_recent_event_timestamp = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)\n    most_recent_event = None\n\n    # for each response item ....\n    for item in formatted_data:\n        # convert Bugfender event timestamp from rfc3339 to utc\n        timestamp_rfc3339 = item.get(\"timestamp\")\n        timestamp_utc = bf.convert_rfc3339_to_utc(timestamp_rfc3339, helper)\n        timestamp_utc_seconds = bf.convert_rfc3339_to_utc_total_seconds(timestamp_rfc3339, helper)\n\n        # update most recent timestamp and event\n        if(timestamp_utc >= most_recent_event_timestamp):\n            most_recent_event_timestamp = timestamp_utc\n            most_recent_event = item\n \n        event = helper.new_event(data=json.dumps(item), time=timestamp_utc_seconds, source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype())\n        ew.write_event(event)\n        event_count += 1\n\n    helper.log_debug(f\"Data queried from endpoint {api_endpoint} successfully written to Splunk. {event_count} events in total were indexed.\")\n\n    # save most recent date\n    # helper.save_check_point(last_timestamp_checkpoint_key, most_recent_event_timestamp.strftime(\"%Y-%m-%dT%H:%M:%SZ\"))\n    \n    helper.log_debug(f\"most recent event: {most_recent_event}\")\n    bf.set_latest_timestamp(helper, most_recent_event_timestamp)", "uuid": "08f5d38650704f3a954a71325f381f6f", "sample_count": 0}, {"index": "default", "sourcetype": "bugfender:app:issues", "interval": "500", "use_external_validation": true, "streaming_mode_xml": true, "name": "bugfender_app_issues", "title": "Bugfender - App Issues", "description": "", "type": "customized", "parameters": [{"name": "global_account", "label": "Global Account", "help_string": "", "required": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": "", "type": "global_account", "value": ""}, {"name": "app_id", "label": "Bugfender App ID", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}, {"name": "issue_status", "label": "Issue Status", "help_string": "", "required": true, "possible_values": [{"value": "issue_status_open", "label": "Open"}, {"value": "issue_status_closed", "label": "Closed"}], "format_type": "radiogroup", "default_value": "issue_status_open", "type": "radiogroup", "value": "issue_status_open"}, {"name": "page_size", "label": "Page Size", "help_string": "", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}, {"required": false, "name": "interval_days", "label": "Interval (in days)", "default_value": "", "placeholder": "", "help_string": "If this input runs for the first time, instead of one API Call, several API calls for different time intervals are made. Here you can specify how long the intervals are.", "type": "text", "format_type": "text", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "global_account", "title": "Global Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "app_id", "title": "Bugfender App ID", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "issue_status", "title": "Issue Status", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [{"value": "issue_status_open", "label": "Open"}, {"value": "issue_status_closed", "label": "Closed"}], "format_type": "radiogroup", "default_value": "issue_status_open"}, {"type": "customized_var", "name": "page_size", "title": "Page Size", "description": "", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "interval_days", "title": "Interval (in days)", "description": "If this input runs for the first time, instead of one API Call, several API calls for different time intervals are made. Here you can specify how long the intervals are.", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    import bugfender_import_data as bf\n    bf.validate_rfc3339(helper.get_arg(\"start_date\"))\n    bf.validate_rfc3339(helper.get_arg(\"end_date\"))\n\ndef collect_events(helper, ew):\n    import json\n    import bugfender_import_data as bf\n    sys.path.insert(0, os.path.join(os.path.dirname(__file__), \"..\", \"lib\"))\n    import pytz\n\n    # get response from Bugfender API\n    api_endpoint = \"/issues\"\n    issues_list = bf.get_bugfender_data(helper, api_endpoint)\n\n    event_count = 0\n    last_timestamp = bf.get_latest_timestamp(helper)\n\n    # Retrieve latest saved timestamp, if it is None, use date far in the past\n    if last_timestamp is not None:\n        most_recent_event_timestamp = datetime.datetime.strptime(last_timestamp, \"%Y-%m-%dT%H:%M:%SZ\").replace(tzinfo=pytz.utc)\n    else:\n        most_recent_event_timestamp = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)\n    most_recent_event = None\n\n    # for each issue...\n    for issue in issues_list:\n        # convert Bugfender event timestamp from rfc3339 to utc to use with the event\n        timestamp_rfc3339 = issue.get(\"created_at\")\n        timestamp_utc = bf.convert_rfc3339_to_utc(timestamp_rfc3339, helper)\n        timestamp_utc_seconds = bf.convert_rfc3339_to_utc_total_seconds(timestamp_rfc3339, helper)\n\n        # update most recent timestamp and event\n        if(timestamp_utc >= most_recent_event_timestamp):\n            most_recent_event_timestamp = timestamp_utc\n            most_recent_event = issue\n\n        event = helper.new_event(source=helper.get_input_type(), time=timestamp_utc_seconds, index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=json.dumps(issue))\n        ew.write_event(event)\n        event_count += 1\n\n    helper.log_debug(f\"Data queried from endpoint {api_endpoint} successfully written to Splunk. {event_count} events in total were indexed.\")\n\n    helper.log_debug(f\"most recent event: {most_recent_event}\")\n    bf.set_latest_timestamp(helper, most_recent_event_timestamp)", "customized_options": [{"name": "global_account", "value": ""}, {"name": "app_id", "value": ""}, {"name": "issue_status", "value": "issue_status_open"}, {"name": "page_size", "value": ""}, {"name": "interval_days", "value": ""}], "uuid": "c4da60a35dbb4c3f940e0ad2507ac4e4", "sample_count": "292"}]}, "field_extraction_builder": {"bugfender:app:logs": {"data_format": "json"}, "bugfender:app:devices": {"data_format": "json"}, "bugfender:app:issues": {"data_format": "json"}, "bugfender:app:list": {"data_format": "json"}}, "global_settings_builder": {"global_settings": {"log_settings": {}, "credential_settings": []}}, "sourcetype_builder": {"bugfender:app:logs": {"metadata": {"event_count": 0, "data_input_name": "bugfender_app_logs", "extractions_count": 0, "cims_count": 0}}, "bugfender:app:issues": {"metadata": {"event_count": 0, "data_input_name": "bugfender_app_issues", "extractions_count": 0, "cims_count": 0}}, "bugfender:app:list": {"metadata": {"event_count": 0, "data_input_name": "bugfender_app_list", "extractions_count": 0, "cims_count": 0}}, "bugfender:app:devices": {"metadata": {"event_count": 0, "data_input_name": "bugfender_app_devices", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_started", "validation_id": "v_1688021889_26"}}